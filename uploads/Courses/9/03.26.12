Hint for assignment due on Friday:
#include <string.h>
#define WHITE "\t  \n"
#define MAXARG 20
void parse(char *cmd, char *argv[])
{
	int i=0;
	argv[i]=strtok(cmd, WHITE);
	i++;
	while(i<MAXARG && (argv[i]=strtok(NULL, WHITE)) != NULL)
		i++;
}


main()
{
	char cmd[100];
	char *argv[20];
}

The fork() function has a parent and a child process.

In the parent process, if the & is detected, do not wait. Otherwise, wait.
In the child process, call parse followed by execvp.

********************************************************************************
********************************************************************************

Signals

A signal is an event generated by the system in response to some condition.
Upon receipt of which a process may in turn take some action(s).

Default Actions:
	quit, terminate the process without core dump
	dump, terminate the process and generate a core file
	ignore
	abort
	stop, suspend (have the ability to resume the process)

$ man 7 signal ===> gives the whole table of actions

SIGABORT 6
SIGALRM 
SIGFPE  (floating point error)
SIGHUP 1 (hang up; happens if you close your terminal, for instance)
SIGINT 2 (quits, no core dump)
SIGKILL 9
SIGSEGV 11 (seg fault)
SIGCHLD
SIGSTOP (can't be changed)
SIGTSTP (suspends process, but from the tty)
SIGCONT (resumes a suspended process)
SIGUSR1 (reserved for user to define action)
SIGUSR2 (reserved for user to define action)

#include <signal.h>
void* signal(int sig, void(*func)(int))

The choices for the (*func) section:
	1) SIG_DEL
	2) SIG_IGN
	3) Call a function

#include ....
...........

void ouch(int sig)
{
	printf("Ouch! -- I got signal %d\n", sig);	
	signal(SIGINT, SIG_DFL);
}

int main()
{
	signal(SIGINT, ouch);
	while(1)
	{
		printf("Hello \n");
		sleep(1);
	}

	exit(0);
}

Some cool examples:

void ouch(int sig)
{
	kill(getpid(), SIGSEGV);	
}

signal(SIGSEGV, ouch);
void ouch(int sig)
{
	printf("The network is not working!");	
}
